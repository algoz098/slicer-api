import type { CoreInput, GCodeContext } from '../../../../types/slicer'

/**
 * WriterFacade (TS) — gera G-code de alto nível a partir de CoreInput e contexto.
 * Nesta primeira versão, cobre preâmbulo e parâmetros (temperaturas, accel/jerk),
 * com comentários citando as fontes do OrcaSlicer (arquivo/linhas) para cada bloco.
 */
export class WriterFacadeTs {
  constructor() {}

  generate(core: CoreInput): string {
    const ctx: GCodeContext = this.buildContext(core)

    let out = ''

    // Header de compatibilidade (comentários) — inspirado no OrcaSlicer
    out += this.header(core)

    // Preamble (posicionamento, unidades, extrusão, temps, motion)
    out += this.preamble(ctx, core)

    // Config block para compatibilidade com Orca
    out += this.configBlock(core)

    // Custom start gcode resolvido do perfil (se disponível)
    const startResolved = (core.profiles?.process as any)?.machine_start_gcode_resolved
    if (typeof startResolved === 'string' && startResolved.trim().length > 0) {
      out += startResolved.trim() + '\n'
    }

    // TODO: quando o slicing estiver disponível, concatenar movimentos por camadas aqui.
    out += this.minimalLayer(core)

    // Custom end gcode resolvido do perfil (se disponível)
    const endResolved = (core.profiles?.process as any)?.machine_end_gcode_resolved
    if (typeof endResolved === 'string' && endResolved.trim().length > 0) {
      out += endResolved.trim() + '\n'
    }

    out += this.postamble(ctx)

    return out
  }

  generatePreamble(core: CoreInput): string {
    const ctx: GCodeContext = this.buildContext(core)
    return this.preamble(ctx, core)
  }

  private buildContext(core: CoreInput): GCodeContext {
    const processCfg: any = core.profiles?.process || {}
    const eRel = !!processCfg.use_relative_e_distances
    return {
      flavor: core.flavor || 'Marlin',
      units: 'mm',
      eMode: eRel ? 'relative' : 'absolute',
      pre: undefined,
      post: undefined
    }
  }

  /**
   * Header de compatibilidade com OrcaSlicer (comentários no topo do arquivo)
   * Inclui placeholders esperados pelo preview do Orca.
   */
  private header(core: CoreInput): string {
    const pad = (n: number) => n.toString().padStart(2, '0')
    const now = new Date()
    const y = now.getFullYear()
    const m = pad(now.getMonth() + 1)
    const d = pad(now.getDate())
    const hh = pad(now.getHours())
    const mm = pad(now.getMinutes())
    const ss = pad(now.getSeconds())

    const filament = core.profiles?.filament || {}
    const process = core.profiles?.process || {}

    const density = (filament.filament_density ?? process.filament_density ?? 1.24) as number | string
    const diameter = (filament.filament_diameter ?? process.filament_diameter ?? 1.75) as number | string
    const maxZ = (process.layer_height ?? 0.2) as number | string

    const lines: string[] = []
    lines.push('; HEADER_BLOCK_START')
    lines.push(`; generated by OrcaSlicer Core (TS writer) on ${y}-${m}-${d} at ${hh}:${mm}:${ss}`)
    lines.push('; model printing time: estimated')
    lines.push('; total layer number: 1')
    lines.push(';_GP_TOTAL_LAYER_NUMBER_PLACEHOLDER')
    lines.push('; model label id: 1000')
    lines.push(`; filament_density: ${density}`)
    lines.push(`; filament_diameter: ${diameter}`)
    lines.push(`; max_z_height: ${maxZ}`)
    lines.push('; HEADER_BLOCK_END')
    lines.push('')
    return lines.join('\n') + '\n'
  }
  /**
   * Bloco de configuração (comentários) semelhante ao OrcaSlicer
   * Emite um subconjunto de parâmetros chave extraídos dos profiles.
   */
  private configBlock(core: CoreInput): string {
    const p = (core.profiles?.process || {}) as any
    const f = (core.profiles?.filament || {}) as any
    const m = (core.profiles?.machine || {}) as any

    const kv = (k: string, v: any) => `; ${k} = ${v}`
    const lines: string[] = []
    lines.push('; CONFIG_BLOCK_START')
    // Subconjunto essencial (adicionar conforme necessário)
    if (p.acceleration != null) lines.push(kv('default_acceleration', p.acceleration))
    if (p.travel_acceleration != null) lines.push(kv('travel_acceleration', p.travel_acceleration))
    if (p.print_speed != null) lines.push(kv('print_speed', p.print_speed))
    if (p.travel_speed != null) lines.push(kv('travel_speed', p.travel_speed))
    if (p.layer_height != null) lines.push(kv('layer_height', p.layer_height))
    if (p.nozzle_diameter != null) lines.push(kv('nozzle_diameter', p.nozzle_diameter))
    if (p.use_relative_e_distances != null) lines.push(kv('use_relative_e_distances', p.use_relative_e_distances))
    if (f.filament_density != null) lines.push(kv('filament_density', f.filament_density))
    if (f.filament_diameter != null) lines.push(kv('filament_diameter', f.filament_diameter))
    if (p.first_layer_bed_temperature != null) lines.push(kv('first_layer_bed_temperature', p.first_layer_bed_temperature))
    if (p.first_layer_temperature != null) lines.push(kv('first_layer_temperature', p.first_layer_temperature))
    if (m.printer_model != null) lines.push(kv('printer_model', m.printer_model))
    if (m.printable_area != null) lines.push(kv('printable_area', m.printable_area))
    lines.push('; CONFIG_BLOCK_END')
    lines.push('')
    return lines.join('\n') + '\n'
  }
  /**
   * Emite uma camada mínima com comentários e movimentos, para paridade de estrutura
   */
  private minimalLayer(core: CoreInput): string {
    const lines: string[] = []
    const lh = (core.profiles?.process as any)?.layer_height || 0.2

    lines.push('; CHANGE_LAYER')
    lines.push(`; Z_HEIGHT: ${lh}`)
    lines.push(`; LAYER_HEIGHT: ${lh}`)
    lines.push('; layer num/total_layer_count: 1/1')
    lines.push('')
    lines.push('; printing object TestObject id:0 copy 0')
    lines.push('G1 X100 Y100 F6000 ; move to start position')
    lines.push(`G1 Z${lh} F1200 ; move to first layer height`)
    lines.push('G1 E0 F1800 ; reset extruder position')
    lines.push('')

    // Outer wall square 10x10
    lines.push('; FEATURE: Outer wall')
    lines.push('G1 F1800')
    lines.push('G1 X110 Y100 E0.42 ; print line (10mm @ 0.042 mm^3/mm approx)')
    lines.push('G1 X110 Y110 E0.84')
    lines.push('G1 X100 Y110 E1.26')
    lines.push('G1 X100 Y100 E1.68')
    lines.push('')

    // Inner wall square 6x6
    lines.push('; FEATURE: Inner wall')
    lines.push('G1 X102 Y102 F6000 ; move to inner wall')
    lines.push('G1 F1800')
    lines.push('G1 X108 Y102 E1.93')
    lines.push('G1 X108 Y108 E2.18')
    lines.push('G1 X102 Y108 E2.43')
    lines.push('G1 X102 Y102 E2.68')
    lines.push('')

    // Sparse infill line
    lines.push('; FEATURE: Sparse infill')
    lines.push('G1 X104 Y104 F6000 ; move to infill')
    lines.push('G1 F1800')
    lines.push('G1 X106 Y106 E2.85 ; infill line')
    lines.push('')

    return lines.join('\n') + '\n'
  }

  /**
   * Preamble de acordo com GCodeWriter::preamble do OrcaSlicer
   * Fonte: source_OrcaSlicer/src/libslic3r/GCodeWriter.cpp:L64–85
   * - (L64–67) Se flavor != MakerWare: G90; G21
   * - (L69–76) Flavors suportados disparam M82/M83 e reset E
   * - (L77–83) M82 vs M83 e reset de E (this->reset_e(true))
   */
  private preamble(ctx: GCodeContext, core: CoreInput): string {
    const lines: string[] = []

    // L64–67: G90 (absolute) e G21 (mm) quando flavor != MakerWare
    if (!/MakerWare/i.test(ctx.flavor)) {
      lines.push('G90')
      lines.push('G21')
    }

    // L69–83: M82/M83 conforme eMode e reset de E (aproximação com G92 E0)
    if (/(RepRap|Marlin|Teacup|Repetier|Smoothie|Klipper)/i.test(ctx.flavor)) {
      if (ctx.eMode === 'relative') lines.push('M83 ; use relative distances for extrusion')
      else lines.push('M82 ; use absolute distances for extrusion')
      // reset_e(true) → aproximado como G92 E0
      lines.push('G92 E0')
    }

    // Temperaturas — ordem aproximada ao Orca: set sem espera, depois espera quando aplicável
    const waitMode = core.temperatures?.waitMode
    const noz = core.temperatures?.nozzle
    const bed = core.temperatures?.bed
    const chamber = core.temperatures?.chamber

    // Primeiro: set sem espera (M104/M140/M141)
    if (typeof bed === 'number') lines.push(this.set_bed_temperature(bed, /*wait*/ false, ctx))
    if (typeof noz === 'number') lines.push(this.set_temperature(noz, /*wait*/ false, ctx))
    if (typeof chamber === 'number') lines.push(this.set_chamber_temperature(chamber, /*wait*/ false, ctx))

    // Depois: espera pelas temperaturas alvo

    if (waitMode === 'M190/M109') {
      if (typeof bed === 'number') lines.push(this.set_bed_temperature(bed, /*wait*/ true, ctx))
      if (typeof noz === 'number') lines.push(this.set_temperature(noz, /*wait*/ true, ctx))
      if (typeof chamber === 'number') lines.push(this.set_chamber_temperature(chamber, /*wait*/ true, ctx))
    } else if (waitMode === 'M116') {
      // RepRapFirmware: M116 aguarda todas as temperaturas
      lines.push('M116')
    }

    // Accel/Jerk (L26–43 apply_print_config; L194+ set_acceleration_internal; L234+ set_jerk_xy)
    const accel = core.motion?.accel
    if (typeof accel === 'number' && accel > 0) lines.push(this.set_acceleration(accel, ctx))
    const jerk = core.motion?.jerk?.x || core.motion?.jerk?.y
    if (typeof jerk === 'number' && jerk > 0) lines.push(this.set_jerk_xy(jerk, ctx))

    // Pequena sequência inicial para “arquivo completo” (homing e purge line) quando TS writer
    lines.push('G28 ; home all axes')
    lines.push('M220 S100')
    lines.push('M221 S100')
    lines.push(';===== start printing =================')
    lines.push('; Purge line')
    lines.push('G1 X0 Y-3 Z0.3 F6000')
    lines.push('G1 X60 E9 F1000')
    lines.push('G1 X100 E12.5 F1000')
    lines.push('G92 E0')

    return lines.filter(Boolean).join('\n') + '\n'
  }
  /**
   * Sequência de finalização mais completa (postamble)
   * Fonte: GCodeWriter.cpp:L88–94 (adaptado por flavor)
   */
  private postamble(ctx: GCodeContext): string {
    const lines: string[] = []
    // Desligar heaters e fans (genérico)
    lines.push('M104 S0') // nozzle off
    lines.push('M140 S0') // bed off
    lines.push('M106 S0') // fan off

    // Posicionamento e extrusão absoluta para encerrar
    if (!/MakerWare/i.test(ctx.flavor)) lines.push('G90')
    if (/(RepRap|Marlin|Teacup|Repetier|Smoothie|Klipper)/i.test(ctx.flavor)) lines.push('M82')

    // Motores off
    if (/Machinekit/i.test(ctx.flavor)) lines.push('M2 ; end of program')
    else lines.push('M84')

    lines.push('; Print completed successfully')
    return lines.join('\n') + '\n'
  }



  /**
   * set_temperature — GCodeWriter::set_temperature (L96–145)
   * Respeita flavor e parâmetro wait, com comentários equivalentes
   */
  private set_temperature(temperature: number, wait: boolean, ctx: GCodeContext): string {
    const flavor = ctx.flavor
    if (wait && /(MakerWare|Sailfish)/i.test(flavor)) return ''

    let code = ''
    let comment = ''
    if (wait && !/(Teacup|RepRapFirmware)/i.test(flavor)) {
      code = 'M109'
      comment = 'set nozzle temperature and wait for it to be reached'
    } else {
      if (/RepRapFirmware/i.test(flavor)) code = 'G10'
      else code = 'M104'
      comment = 'set nozzle temperature'
    }
    return `${code} S${Math.round(temperature)} ; ${comment}`
  }

  /** set_bed_temperature — L146–169 */
  private set_bed_temperature(temperature: number, wait: boolean, _ctx: GCodeContext): string {
    const code = wait ? 'M190' : 'M140'
    const comment = wait ? 'set bed temperature and wait for it to be reached' : 'set bed temperature'
    return `${code} S${Math.round(temperature)} ; ${comment}`
  }

  /** set_chamber_temperature — L171–191 */
  private set_chamber_temperature(temperature: number, wait: boolean, ctx: GCodeContext): string {
    const lines: string[] = []
    if (wait) {
      // Aux fan (P2) seria controlado pelo config.auxiliary_fan no Orca; sem esse dado aqui, omitimos.
      if (/RepRapFirmware|Marlin|Klipper|Repetier|Smoothie|Teacup|Sprinter|MakerWare|Sailfish/i.test(ctx.flavor)) {
        // Orca usa M191 e pode usar M106 P2; aqui simplificado para M191 apenas.
        lines.push(`M191 S${Math.round(temperature)} ; set chamber_temperature and wait for it to be reached`)
      }
    } else {
      lines.push(`M141 S${Math.round(temperature)} ; set chamber_temperature`)
    }
    return lines.join('\n')
  }

  /** set_acceleration_internal — L194+ (simplificado por flavor) */
  private set_acceleration(accel: number, ctx: GCodeContext): string {
    const f = ctx.flavor
    if (/Repetier/i.test(f)) return `M201 X${accel} Y${accel} ; adjust acceleration`
    if (/RepRapFirmware|Marlin/i.test(f)) return `M204 P${accel} ; adjust acceleration`
    if (/Klipper/i.test(f)) return `SET_VELOCITY_LIMIT ACCEL=${accel} ; adjust ACCEL`
    return `M204 S${accel} ; adjust acceleration`
  }

  /** set_jerk_xy — L234+ */
  private set_jerk_xy(jerk: number, ctx: GCodeContext): string {
    if (/Klipper/i.test(ctx.flavor)) return `SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=${jerk}`
    return `M205 X${jerk} Y${jerk}`
  }
}

