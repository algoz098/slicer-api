/*
 Node test that replicates OrcaSlicerCli/test_slice.sh using the Node addon.
 - Slices STL with printer/filament/process profiles extracted from reference G-code
 - Compares: line count, HEADER_BLOCK (ignoring timestamp), CONFIG_BLOCK, and first diff context in G-code commands
 - Slices 3MF plate 1 and 2 and compares similarly (with additional ID normalizations)
 Usage (from repo root):
   cd OrcaSlicerCli && node bindings/node/test/slice_compare.js
*/

const fs = require('fs');
const path = require('path');
const os = require('os');

function readText(file) { return fs.readFileSync(file, 'utf8'); }
function exists(p) { try { fs.accessSync(p); return true; } catch { return false; } }
function ensureDir(d) { fs.mkdirSync(d, { recursive: true }); }

// Resolve paths
// __dirname = <repo>/OrcaSlicerCli/bindings/node/test
const repoRoot = path.resolve(__dirname, '../../../..');
const cliRoot = path.join(repoRoot, 'OrcaSlicerCli');
const buildRootRepo = path.join(repoRoot, 'build');
const buildRootCli = path.join(cliRoot, 'build');
const primaryAddon = path.join(buildRootRepo, 'bindings', 'node', 'orcaslicer_node.node');
const fallbackAddon = path.join(buildRootCli, 'bindings', 'node', 'orcaslicer_node.node');
const addonBin = exists(primaryAddon) ? primaryAddon : fallbackAddon;
const orca = require(addonBin);

const exampleDir = path.join(repoRoot, 'example_files');
const comparableDir = path.join(repoRoot, 'comparable_files');
const outputDir = path.join(cliRoot, 'output_files');

const REF_STL_GCODE = path.join(comparableDir, '3DBenchy.gcode');
const INPUT_STL = path.join(exampleDir, '3DBenchy.stl');
const OUT_STL = path.join(outputDir, 'test_with_profiles.gcode');

const INPUT_3MF = path.join(exampleDir, '3DBenchy.3mf');
const OUT_3MF1 = path.join(outputDir, 'output_3DBenchy_plate_1.gcode');
const OUT_3MF2 = path.join(outputDir, 'output_3DBenchy_plate_2.gcode');
const REF_3MF1 = path.join(comparableDir, '3DBenchy_plate_1.gcode');
const REF_3MF2 = path.join(comparableDir, '3DBenchy_plate_2.gcode');

function extractBetween(text, start, end) {
  const s = text.indexOf(start);
  if (s === -1) return '';
  const e = text.indexOf(end, s);
  if (e === -1) return text.slice(s);
  return text.slice(s, e + end.length);
}

function extractHeaderBlock(text) {
  return extractBetween(text, '; HEADER_BLOCK_START', '; HEADER_BLOCK_END');
}
function extractConfigBlock(text) {
  return extractBetween(text, '; CONFIG_BLOCK_START', '; CONFIG_BLOCK_END');
}
function extractGcodeCommands(text) {
  const idx = text.indexOf('; CONFIG_BLOCK_END');
  if (idx === -1) return '';
  // drop the line with CONFIG_BLOCK_END and the next line (tail -n +2)
  const after = text.slice(idx);
  const lines = after.split(/\r?\n/);
  return lines.slice(2).join('\n');
}

function normalizeHeaderBlock(text) {
  return text
    .split(/\r?\n/)
    .filter(l => !l.startsWith('; generated by '))
    .map(l => l.replace(/^; model label id: .*$/,'; model label id: IGNORED'))
    .join('\n');
}

function normalizeFirstPrintingObjectId(text) {
  const re = /^; (printing|stop printing) object .* id:[0-9]+ copy /;
  return text.split(/\r?\n/).map(l => re.test(l) ? l.replace(/id:[0-9]+/, 'id:IGNORED') : l).join('\n');
}
function normalizeUniqueLabelId(text) {
  // for 3MF comparisons
  return text.split(/\r?\n/).map(l => l
    .replace(/^; start printing object, unique label id: [0-9]+$/, '; start printing object, unique label id: IGNORED')
    .replace(/^; stop printing object, unique label id: [0-9]+$/, '; stop printing object, unique label id: IGNORED')
  ).join('\n');
}

function diffFirstLine(a, b) {
  const la = a.split(/\r?\n/);
  const lb = b.split(/\r?\n/);
  const n = Math.max(la.length, lb.length);
  for (let i = 0; i < n; i++) {
    const aa = la[i] ?? '';
    const bb = lb[i] ?? '';
    if (aa !== bb) return i + 1; // 1-based
  }
  return 0; // no diff
}

function showContext(a, b, startLine, ctx = 10) {
  const la = a.split(/\r?\n/);
  const lb = b.split(/\r?\n/);
  const s = Math.max(0, startLine - 1);
  const e = Math.min(Math.max(la.length, lb.length), s + ctx);
  const ref = la.slice(s, e).join('\n');
  const gen = lb.slice(s, e).join('\n');
  console.log('--- a/GCODE_COMMANDS (referência)');
  console.log(ref);
  console.log('+++ b/GCODE_COMMANDS (gerado)');
  console.log(gen);
}

function extractProfilesFromGcodeText(g) {
  const matchPrinter = g.match(/^; printer_settings_id = (.*)$/m);
  const matchProcess = g.match(/^; print_settings_id = (.*)$/m);
  const matchFilament = g.match(/^; filament_settings_id = (.*)$/m);
  let filament = matchFilament ? matchFilament[1] : '';
  filament = filament.split(';')[0].trim().replace(/^"|"$/g, '');
  return {
    printer: matchPrinter ? matchPrinter[1].trim() : '',
    process: matchProcess ? matchProcess[1].trim() : '',
    filament,
  };
}

async function sliceWithProfiles({ input, output, profiles, plate }) {
  ensureDir(path.dirname(output));
  try { fs.unlinkSync(output); } catch {}
  try { fs.unlinkSync(output + '.tmp'); } catch {}
  const res = await orca.slice({
    input,
    output,
    printerProfile: profiles?.printer || undefined,
    filamentProfile: profiles?.filament || undefined,
    processProfile: profiles?.process || undefined,
    plate: plate || undefined,
    verbose: false,
    dryRun: false,
  });
  // use output path from params (addon echoes back)
  return res.output;
}

function sizeBytes(file) {
  try { return fs.statSync(file).size; } catch { return 0; }
}

(async () => {
  let allOk = true;
  try {
    const resourcesPathEnv = process.env.ORCACLI_RESOURCES;
    const defaultResources = path.join(repoRoot, 'OrcaSlicer', 'resources');
    const chosen = (resourcesPathEnv && resourcesPathEnv.trim().length) ? resourcesPathEnv : defaultResources;
    // Resolve relative paths against the repo root, not bindings/node
    // If ORCACLI_RESOURCES is relative, resolve it against the CLI root (so '../OrcaSlicer/resources' works when run from OrcaSlicerCli)
    const resourcesPath = path.isAbsolute(chosen) ? chosen : path.resolve(cliRoot, chosen);
    orca.initialize({ resourcesPath, verbose: false });

    // ---------- Teste 1: STL + comparação detalhada ----------
    if (!exists(INPUT_STL)) throw new Error(`Entrada STL inexistente: ${INPUT_STL}`);
    const refText = readText(REF_STL_GCODE);
    const profiles = extractProfilesFromGcodeText(refText);
    if (!profiles.printer || !profiles.filament || !profiles.process) {
      throw new Error('Não foi possível extrair perfis do G-code de referência');
    }

    console.log('🔧 Testando slice (STL)');
    console.log('📋 Perfis:', profiles);
    const out1 = await sliceWithProfiles({ input: INPUT_STL, output: OUT_STL, profiles });

    const produced = exists(out1) ? out1 : (exists(OUT_STL + '.tmp') ? OUT_STL + '.tmp' : out1);
    if (!exists(produced)) throw new Error('Nenhum G-code foi gerado');
    const bytes = sizeBytes(produced);
    if (bytes <= 1_000_000) { console.error(`❌ ERRO: Arquivo muito pequeno (${bytes} bytes)`); allOk = false; }
    else console.log(`✅ SUCESSO: G-code gerado com ${(bytes/1024/1024).toFixed(2)}MB`);

    if (exists(REF_STL_GCODE)) {
      let errors = 0;
      const genText = readText(produced);
      // 1) Número de linhas
      const refLines = refText.split(/\r?\n/).length;
      const genLines = genText.split(/\r?\n/).length;
      console.log('📊 Teste 1: Linhas — ref=%d, out=%d', refLines, genLines);
      if (refLines !== genLines) { console.error('❌ Linhas diferentes'); errors++; }
      else console.log('✅ Número de linhas: idêntico');

      // 2) HEADER_BLOCK (ignora timestamp)
      console.log('\n📊 Teste 2: HEADER_BLOCK');
      const refHeader = normalizeHeaderBlock(extractHeaderBlock(refText));
      const genHeader = normalizeHeaderBlock(extractHeaderBlock(genText));
      if (refHeader !== genHeader) {
        console.error('❌ HEADER_BLOCK diferente');
        console.log('--- a/HEADER_BLOCK');
        console.log(refHeader);
        console.log('+++ b/HEADER_BLOCK');
        console.log(genHeader);
        errors++;
      } else {
        console.log('✅ HEADER_BLOCK: idêntico (ignorando timestamp)');
      }

      // 3) CONFIG_BLOCK
      console.log('\n📊 Teste 3: CONFIG_BLOCK');
      const refCfg = extractConfigBlock(refText);
      const genCfg = extractConfigBlock(genText);
      if (refCfg !== genCfg) {
        console.error('❌ CONFIG_BLOCK diferente');
        console.log('--- a/CONFIG_BLOCK');
        console.log(refCfg);
        console.log('+++ b/CONFIG_BLOCK');
        console.log(genCfg);
        errors++;
      } else {
        console.log('✅ CONFIG_BLOCK: idêntico');
      }

      // 4) G-code commands — primeira diferença + contexto
      console.log('\n📊 Teste 4: G-code commands (primeira diferença + 10 linhas)');
      let refCmd = extractGcodeCommands(refText);
      let genCmd = extractGcodeCommands(genText);
      refCmd = normalizeFirstPrintingObjectId(refCmd);
      genCmd = normalizeFirstPrintingObjectId(genCmd);
      const first = diffFirstLine(refCmd, genCmd);
      if (first === 0) console.log('✅ Comandos G-code: idênticos');
      else {
        console.error('❌ G-code diferente — primeira diferença na linha', first);
        showContext(refCmd, genCmd, first, 10);
        errors++;
      }

      if (errors === 0) console.log('\n🏁 Resultado STL: ✅ SUCESSO — idêntico ao de referência');
      else { console.log('\n🏁 Resultado STL: ❌ FALHA — diferenças detectadas'); allOk = false; }
    } else {
      console.warn('⚠️  Referência STL não encontrada; pulando comparações.');
    }

    // ---------- Teste 2: 3MF plate 1 ----------
    if (!exists(INPUT_3MF)) {
      console.warn('⚠️  Arquivo 3MF não encontrado; pulando testes 3MF.');
    } else {
      console.log('\n==== Teste 2: 3MF (plate 1) ====');
      const out3mf1 = await sliceWithProfiles({ input: INPUT_3MF, output: OUT_3MF1, profiles: null, plate: 1 });
      const gen1 = exists(out3mf1) ? readText(out3mf1) : '';
      let ok1 = true;
      if (exists(REF_3MF1)) {
        let errs = 0;
        const ref1 = readText(REF_3MF1);
        const refLines = ref1.split(/\r?\n/).length; const outLines = gen1.split(/\r?\n/).length;
        console.log('[3MF] Linhas: ref=%d, out=%d', refLines, outLines);
        if (refLines !== outLines) errs++;
        const refHdr = normalizeHeaderBlock(extractHeaderBlock(ref1));
        const genHdr = normalizeHeaderBlock(extractHeaderBlock(gen1));
        if (refHdr !== genHdr) { console.log('HEADER_BLOCK (3MF) difere'); errs++; }
        const refCfg = extractConfigBlock(ref1);
        const genCfg = extractConfigBlock(gen1);
        if (refCfg !== genCfg) { console.log('CONFIG_BLOCK (3MF) difere'); errs++; }
        let refCmd = extractGcodeCommands(ref1);
        let genCmd = extractGcodeCommands(gen1);
        refCmd = normalizeUniqueLabelId(refCmd); refCmd = normalizeFirstPrintingObjectId(refCmd);
        genCmd = normalizeUniqueLabelId(genCmd); genCmd = normalizeFirstPrintingObjectId(genCmd);
        const first = diffFirstLine(refCmd, genCmd);
        if (first !== 0) { console.log(`G-code (3MF plate 1) difere a partir da linha ${first}.`); errs++; }
        ok1 = errs === 0;
        console.log(ok1 ? '[3MF plate 1] SUCESSO' : '[3MF plate 1] FALHA');
      } else {
        console.warn('Referência 3MF plate 1 não encontrada; pulando comparação.');
      }
      allOk = allOk && ok1;

      // ---------- Teste 2b: 3MF plate 2 ----------
      console.log('\n==== Teste 2b: 3MF (plate 2) ====');
      const out3mf2 = await sliceWithProfiles({ input: INPUT_3MF, output: OUT_3MF2, profiles: null, plate: 2 });
      const gen2 = exists(out3mf2) ? readText(out3mf2) : '';
      let ok2 = true;
      if (exists(REF_3MF2)) {
        let errs = 0;
        const ref2 = readText(REF_3MF2);
        const refLines = ref2.split(/\r?\n/).length; const outLines = gen2.split(/\r?\n/).length;
        console.log('[3MF plate 2] Linhas: ref=%d, out=%d', refLines, outLines);
        if (refLines !== outLines) errs++;
        const refHdr = normalizeHeaderBlock(extractHeaderBlock(ref2));
        const genHdr = normalizeHeaderBlock(extractHeaderBlock(gen2));
        if (refHdr !== genHdr) { console.log('HEADER_BLOCK (3MF plate 2) diferente.'); errs++; }
        const refCfg = extractConfigBlock(ref2);
        const genCfg = extractConfigBlock(gen2);
        if (refCfg !== genCfg) { console.log('CONFIG_BLOCK (3MF plate 2) diferente.'); errs++; }
        let refCmd = extractGcodeCommands(ref2);
        let genCmd = extractGcodeCommands(gen2);
        refCmd = normalizeUniqueLabelId(refCmd); refCmd = normalizeFirstPrintingObjectId(refCmd);
        genCmd = normalizeUniqueLabelId(genCmd); genCmd = normalizeFirstPrintingObjectId(genCmd);
        const first = diffFirstLine(refCmd, genCmd);
        if (first !== 0) { console.log(`G-code (3MF plate 2) difere a partir da linha ${first}.`); errs++; }
        ok2 = errs === 0;
        console.log(ok2 ? '[3MF plate 2] SUCESSO' : '[3MF plate 2] FALHA');
      } else {
        console.warn('Referência 3MF plate 2 não encontrada; pulando comparação.');
      }
      allOk = allOk && ok2;
    }
  } catch (e) {
    console.error('Teste falhou:', e);
    process.exitCode = 1;
    return;
  } finally {
    try { orca.shutdown && orca.shutdown(); } catch (_) {}
  }

  if (allOk) {
    console.log('\nTodos os testes (STL e 3MF) passaram com sucesso!');
    process.exitCode = 0;
  } else {
    console.log('\nFalhas detectadas em um ou mais testes.');
    process.exitCode = 1;
  }
})();

