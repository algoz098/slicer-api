# OrcaSlicer CLI

Uma interface de linha de comando para o OrcaSlicer, permitindo fatiar arquivos STL e gerar G-code sem interface gráfica.

## 📁 Estrutura do Projeto

```
.
├── OrcaSlicer/          # Código fonte original do OrcaSlicer (não modificar)
├── OrcaSlicerCli/       # Interface CLI (trabalho em progresso)
├── example_files/       # Arquivos de exemplo para teste
│   └── 3DBenchy.stl    # Modelo de teste
├── output_files/        # Arquivos G-code gerados
├── slice_3dbenchy.sh    # Script automatizado de fatiamento
└── README.md           # Este arquivo
```

## 🚀 Uso Rápido

### Script Automatizado

Para fatiar o 3DBenchy.stl rapidamente:

```bash
./slice_3dbenchy.sh
```

Este script:
- ✅ Verifica se todos os arquivos necessários existem
- ✅ Executa o fatiamento do 3DBenchy.stl
- ✅ Gera G-code completo na pasta `output_files/`
- ✅ Lida automaticamente com o segfault na finalização
- ✅ Fornece feedback colorido do progresso

### Uso Manual

```bash
cd OrcaSlicerCli/build
./bin/orcaslicer-cli slice --input ../../example_files/3DBenchy.stl --output ../../output_files/3DBenchy.gcode
```

- Exportar 3MF de produção (G-code embutido) a partir de um projeto .3mf (plate 1):
```bash
./bin/orcaslicer-cli slice \
  --input ../../example_files/3DBenchy.3mf \
  --output ../../output_files/3DBenchy_plate_1.gcode.3mf \
  --plate 1
```

- Plate 2:
```bash
./bin/orcaslicer-cli slice \
  --input ../../example_files/3DBenchy.3mf \
  --output ../../output_files/3DBenchy_plate_2.gcode.3mf \
  --plate 2
```

Dica: a extensão do arquivo de saída define o formato gerado. Se terminar com `.3mf`, o CLI empacota o G-code em um 3MF de produção (paridade com o Orca GUI: SaveStrategy `Silence|SplitModel|WithGcode|SkipModel|Zip64`). Caso contrário, gera `.gcode` puro.

## 🧩 Paridade com o GUI para 3MF de produção (G-code embutido)

- O CLI reproduz o mesmo fluxo do GUI ao exportar 3MF de produção (Export plate sliced file):
  - PresetBundle → full_config_secure()
  - Print.apply() → Print.process() → Print.export_gcode()
  - Empacotamento via store_bbs_3mf() com SaveStrategy: Silence | SplitModel | WithGcode | SkipModel | Zip64
- A extensão do arquivo de saída controla o modo:
  - .gcode → G-code puro
  - .3mf → 3MF de produção com G-code embutido (gcode.3mf)
- Seleção de plate em projetos .3mf: use --plate N (1‑based). O índice é propagado para Print e Model de forma idêntica ao GUI, garantindo parâmetros por-placa corretos (ex.: wipe_tower_x/y).

### Critérios de comparação/validação (paridade)
Para comparar o G-code embutido com arquivos gerados pelo GUI, usamos as regras abaixo:
- Ignorar no HEADER: a linha “generated by …” (data/hora) e “model label id”.
- Exigir paridade real de tempos: “model printing time” e “total estimated time”.
- Exigir paridade integral do CONFIG_BLOCK (inclui wipe_tower_x/y por placa).
- No corpo do G-code, ignorar linhas M73 (progresso), pois variam com o ambiente.

### Teste automatizado de paridade
Há um teste pronto que gera .gcode.3mf para plates 1 e 2 a partir de example_files/3DBenchy.3mf e compara com os arquivos de referência em comparable_files/:

```bash
cd OrcaSlicerCli
bash test_3mf_production.sh
```

Saída esperada:
- “G-code embutido idêntico ao de referência (com normalizações permitidas)” para cada plate.

Observação: Os arquivos de referência foram gerados com o mesmo build do OrcaSlicer (GUI). Se você atualizar o OrcaSlicer, gere novos arquivos de referência para manter a paridade.


## 🔧 Compilação

### Pré-requisitos

- macOS com Xcode Command Line Tools
- CMake 3.13+ (localizado em `/Applications/CMake.app/Contents/bin/cmake`)
- Arquitetura ARM64 (Apple Silicon)

### Compilar o Projeto

```bash
cd OrcaSlicerCli/build
rm -rf *  # Limpar build anterior
/Applications/CMake.app/Contents/bin/cmake ..
make -j4
```

## 📊 Status do Projeto

### ✅ Funcionalidades Implementadas

- **Carregamento de STL**: Lê arquivos STL usando `Slic3r::TriangleMesh::ReadSTLFile()`
- **Configuração Completa**: Usa `DynamicPrintConfig::full_print_config()` com 503 opções
- **Pipeline de Slicing**: Implementa o pipeline completo do OrcaSlicer
  - Aplicação de modelo e configuração
  - Processamento de slicing (paredes, superfícies, preenchimento)
  - Detecção de suporte
  - Verificação de conflitos
- **Geração de G-code**: Exporta G-code completo e válido
- **Interface CLI**: Comandos `slice` e `info` funcionais

### 🔧 Problemas Conhecidos

- **Segfault na Finalização**: O processo termina com segmentation fault após gerar o G-code, mas o arquivo é criado corretamente
- **Arquivo Temporário**: O G-code é salvo como `.tmp` e precisa ser renomeado (o script faz isso automaticamente)

### ✅ Problemas Resolvidos

- **Template filename_format**: Corrigido erro de parsing do template `{filament_type[initial_tool]}` configurando um template simples `{input_filename_base}.gcode`
- **Caminhos Absolutos**: Agora funciona com caminhos absolutos e relativos
- **Diretório de Saída**: Suporte para especificar apenas o diretório (nome do arquivo gerado automaticamente)

### 📈 Resultados

- **Arquivo de Entrada**: `3DBenchy.stl` (225.154 triângulos, 15.550,4 mm³)
- **Arquivo de Saída**: `3DBenchy.gcode` (3.4MB, G-code completo)
- **Tempo de Processamento**: ~2-3 segundos
- **Memória Utilizada**: ~200MB pico

## 🛠️ Detalhes Técnicos

### Dependências Resolvidas

O projeto integra com sucesso as seguintes bibliotecas do OrcaSlicer:

- **libslic3r**: Biblioteca principal de slicing (50MB)
- **libslic3r_cgal**: Extensões CGAL (7MB)
- **Boost**: Headers e bibliotecas
- **Eigen**: Álgebra linear
- **OpenCASCADE**: 38+ bibliotecas CAD
- **TBB**: Threading Building Blocks
- **Outras**: PNG, JPEG, FreeType, Expat, Crypto, etc.

### Configuração

- **Layer Height**: 0.2mm
- **Perimeters**: 3
- **Infill**: 20%
- **Nozzle**: 0.4mm
- **Filament**: 1.75mm PLA
- **Temperatures**: 210°C extruder, 60°C bed

### Arquitetura

```
CliCore.cpp
├── initializeSlic3r()     # Inicializa configuração completa
├── loadModelFromFile()    # Carrega STL usando TriangleMesh
├── performSlicing()       # Pipeline: apply() → process() → export_gcode()
└── getModelInformation()  # Informações do modelo
```


### Multi-plates 3MF (normalização do plate)

- Projetos 3MF (especialmente da Bambu) guardam múltiplos plates em um grid lógico, com um “gap” entre pratos.
- A GUI do OrcaSlicer normaliza o plate selecionado removendo o deslocamento global do grid e recentrando no bed.
- O CLI agora replica exatamente esse comportamento quando usado com `--plate` em arquivos `.3mf`:
  - Calcula o stride do plate a partir da área imprimível (bed) e do gap lógico (`LOGICAL_PART_PLATE_GAP = 1/5`).
  - Estima a coluna/linha do plate a partir dos offsets absolutos das instâncias e recenter para a origem do bed.
  - Aplica apenas para `.3mf` quando `--plate >= 2` (plates além do primeiro). Para STL/OBJ não se aplica.
- Resultado: o G-code do plate selecionado abre na GUI centralizado no bed, igual ao que a GUI mostraria ao fatiar aquele plate.
- Teste 2b (3MF plate 2) valida essa normalização e passou com G-code idêntico ao arquivo de referência.

## 📝 Logs de Exemplo

```
2025-09-15 15:32:53.205 [000INFO] Starting slice operation...
DEBUG: Loaded full print config with 503 options
DEBUG: Model has 1 objects
DEBUG: Apply completed successfully
DEBUG: Print processing completed
[info] Slicing process finished. Resident memory: 199MB; Peak memory usage: 201MB
✅ Fatiamento concluído com sucesso!
📁 Arquivo gerado: output_files/3DBenchy.gcode (3.4M)
```

## 🎯 Próximos Passos

1. **Corrigir Segfault**: Investigar e corrigir o segmentation fault na finalização
2. **Configurações Customizáveis**: Permitir configurações personalizadas via CLI
3. **Múltiplos Formatos**: Suporte para outros formatos além de STL
4. **Otimizações**: Melhorar performance e uso de memória

## 📄 Licença

Este projeto utiliza o código fonte do OrcaSlicer. Consulte as licenças originais do OrcaSlicer para mais informações.

---

**Desenvolvido com OrcaSlicer libslic3r** 🚀
